if(!require(factoextra)) install.packages("factoextra",repos = "http://cran.us.r-project.org")
install.packages(mclust)
library(factoextra)
library(cluster)
library(mclust)
if(!require(factoextra)) install.packages("factoextra",repos = "http://cran.us.r-project.org")
install.packages("mclust")
library(factoextra)
library(cluster)
library(mclust)
if(!require(factoextra)) install.packages("factoextra",repos = "http://cran.us.r-project.org")
if(!require(mclust)) install.packages("mclust",repos = "http://cran.us.r-project.org")
library(factoextra)
library(cluster)
library(mclust)
if(!require(factoextra)) install.packages("factoextra",repos = "http://cran.us.r-project.org")
if(!require(mclust)) install.packages("mclust",repos = "http://cran.us.r-project.org")
library(factoextra)
library(cluster)
library(mclust)
if(!require(factoextra)) install.packages("factoextra",repos = "http://cran.us.r-project.org")
if(!require(mclust)) install.packages("mclust",repos = "http://cran.us.r-project.org")
library(factoextra)
library(cluster)
library(mclust)
model_based <- Mclust(df)
model_based <- mclust(df)
model_based <- Mclust(df)
library(factoextra)
library(cluster)
library(mclust)
df <- USArrests
names(df)
plot(df$Murder, df$Assault)
plot(df$Murder, df$UrbanPop)
plot(df$Murder, df$Rape)
plot(df$Assault, df$UrbanPop)
plot(df$Assault, df$Rape)
plot(df$Assault, df$Rape)
plot(df$UrbanPop, df$Rape)
which(is.na(df))
df <- scale(df)
head(df)
# Find the optimal number of clusters
fviz_nbclust(df, kmeans, method = "wss")
set.seed(1234)
kmodel <- kmeans(df, centers = 4, nstart = 25)
kmodel
fviz_cluster(kmodel, data = df)
# Label the different methods so that we can use all of them and compare which is the best fit for our dataset
methodlabels <- c( "single", "average", "ward", "complete")
names(methodlabels) <- c( "single", "average", "ward", "complete")
ac <- function(x) {
agnes(df, method = x)$ac
}
# Print the computed agglomerative coefficient for each method. The closer to 1, the better the clusters.
sapply(methodlabels, ac)
compute_clusters <- agnes(df, method = "ward")
pltree(compute_clusters, cex = 0.6, hang = -1, main = "Dendrogram")
onlyfour <- cutree(compute_clusters, k=4)
hierar <- cbind(USArrests, cluster = onlyfour)
head(hierar)
model_based <- Mclust(df)
plot(model_based)
0
summary(model_based)
model_based <- Mclust(df)
plot(model_based)
summary(model_based)
clusplot(df, model_based$cluster, color=TRUE, shade=TRUE,
labels=2, lines=0)
library(factoextra)
library(cluster)
library(mclust)
df <- USArrests
names(df)
plot(df$Murder, df$Assault)
plot(df$Murder, df$UrbanPop)
plot(df$Murder, df$Rape)
plot(df$Assault, df$UrbanPop)
plot(df$Assault, df$Rape)
plot(df$Assault, df$Rape)
plot(df$UrbanPop, df$Rape)
which(is.na(df))
df <- scale(df)
head(df)
# Find the optimal number of clusters
fviz_nbclust(df, kmeans, method = "wss")
set.seed(1234)
kmodel <- kmeans(df, centers = 4, nstart = 25)
kmodel
fviz_cluster(kmodel, data = df)
# Label the different methods so that we can use all of them and compare which is the best fit for our dataset
methodlabels <- c( "single", "average", "ward", "complete")
names(methodlabels) <- c( "single", "average", "ward", "complete")
ac <- function(x) {
agnes(df, method = x)$ac
}
# Print the computed agglomerative coefficient for each method. The closer to 1, the better the clusters.
sapply(methodlabels, ac)
compute_clusters <- agnes(df, method = "ward")
pltree(compute_clusters, cex = 0.6, hang = -1, main = "Dendrogram")
onlyfour <- cutree(compute_clusters, k=4)
hierar <- cbind(USArrests, cluster = onlyfour)
head(hierar)
model_based <- Mclust(df)
# this function will actually ask you for which method you would like to use
plot(model_based)
model_based <- Mclust(df)
# this function will actually ask you for which method you would like to use
#plot(model_based)
summary(model_based)
fviz_mclust(model_based, "BIC", palette = "jco")
fviz_mclust(model_based, "classification", geom = "point",
pointsize = 1.5, palette = "jco")
fviz_mclust(model_based, "classification", geom = "point",
pointsize = 1.5, palette = "jco")
fviz_mclust(model_based, "uncertainty", palette = "jco")
